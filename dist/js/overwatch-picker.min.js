'use strict';

angular.module('overwatch-hero-picker', []);
'use strict';

angular.module('overwatch-hero-picker').config(function ($httpProvider) {
    $httpProvider.defaults.cache = true;
});
'use strict';

angular.module('overwatch-hero-picker').component('owHeroList', {
    bindings: {
        selectedHeroes: '='
    },
    template:'<ul class=list><li ng-repeat="hero in $ctrl.heroes | filter: search | orderBy: \'type\'" ng-class="{ \'selected\': $ctrl.selectedHeroes[hero.id], \'disabled\' : !$ctrl.selectedHeroes[hero.id] && $ctrl.maxReached }"><a ng-click=$ctrl.selectHero(hero) href=javscript:void()><img ng-src={{hero.avatar}}><div class=detail-wrapper><span class=name>{{hero.name}}</span></div></a></li></ul>',
    controller: function controller(HeroesService, $document, $scope) {
        var _this = this;

        var checkMaxReached = function checkMaxReached() {
            _this.maxReached = Object.keys(_this.selectedHeroes).length === 6;
        };

        HeroesService.getHeroes().then(function (heroes) {
            _this.heroes = heroes;
        });

        this.focused = true;
        this.selectedHeroes = {};

        checkMaxReached();

        this.selectHero = function (hero) {

            if (angular.isDefined(_this.selectedHeroes[hero.id])) {
                delete _this.selectedHeroes[hero.id];
            } else if (!_this.maxReached) {
                _this.selectedHeroes[hero.id] = hero;
            }

            checkMaxReached();

            if (_this.maxReached) {
                _this.focused = false;
            }
        };

        $scope.$watch('$ctrl.focused', checkMaxReached);

        $document.on('keyup', function (event) {
            if (event.keyCode === 27) {
                _this.focused = false;
                $scope.$apply();
            }
        });
    }
});
'use strict';

angular.module('overwatch-hero-picker').component('owHeroPickerScore', {
    bindings: {
        map: '<',
        counter: '<',
        final: '<'
    },
    controller: function controller() {
        this.abs = Math.abs;
    },
    template:'<div class=score>{{$ctrl.abs($ctrl.final)| number:1 }} <small>(C)&nbsp;{{$ctrl.abs($ctrl.counter)| number: 1 }}</small> <small>(M)&nbsp;{{$ctrl.abs($ctrl.map)| number: 1 }}</small></div>'
});
'use strict';

angular.module('overwatch-hero-picker').component('owHeroPicker', {
    template:'<main class=content><ow-hero-list selected-heroes=$ctrl.selectedHeroes></ow-hero-list><ow-map-list selected-map=$ctrl.selectedMap></ow-map-list><h2>Who do you want to counter? <small>(choose 1 to 6)</small></h2><div class=recommendation ng-show=$ctrl.heroesList.length><h2>You should pick:</h2><ul class="recommended clearfix"><li ng-repeat="hero in $ctrl.heroesList | filter: $ctrl.recommendedFilter"><img ng-src={{hero.avatar}}><ow-hero-picker-score final=$ctrl.heroFinalScore[hero.id] counter=$ctrl.heroCounterScore[hero.id] map=$ctrl.heroMapScore[hero.id]></ow-hero-picker-score></li></ul><h2>And Avoid picking:</h2><ul class="avoid clearfix"><li ng-repeat="hero in $ctrl.heroesList | filter: $ctrl.avoidFilter"><img ng-src={{hero.avatar}}><div class=score>{{$ctrl.heroFinalScore[hero.id] | number:1 }}</div><ow-hero-picker-score final=$ctrl.heroFinalScore[hero.id] counter=$ctrl.heroCounterScore[hero.id] map=$ctrl.heroMapScore[hero.id]></ow-hero-picker-score></li></ul></div></main>',
    controller: function controller($q, $scope, HeroesService, HeroPickerService) {
        var _this = this;

        this.selectedHeroes = [];
        this.heroesList = [];
        this.selectedMap = null;

        $scope.$watch('$ctrl.selectedMap', function (value) {
            if (angular.isDefined(value)) {
                _this.getRecommendedHero();
            }
        });

        $scope.$watchCollection('$ctrl.selectedHeroes', function (value) {
            if (value) {
                _this.getRecommendedHero();
            }
        });

        this.getRecommendedHero = function () {
            return $q.all({
                ratings: HeroPickerService.getRecommendedHero(_this.selectedHeroes, _this.selectedMap),
                heroesList: HeroesService.getHeroes()
            }).then(function (r) {
                _this.heroFinalScore = r.ratings.finalRating;
                _this.heroCounterScore = r.ratings.heroCounterRating;
                _this.heroMapScore = r.ratings.heroMapRating;

                _this.heroesList = r.heroesList.sort(function (heroA, heroB) {
                    return r.ratings.finalRating[heroA.id] - r.ratings.finalRating[heroB.id];
                });
            });
        };

        this.recommendedFilter = function (hero) {
            return _this.heroFinalScore[hero.id] <= 0;
        };
        this.avoidFilter = function (hero) {
            return _this.heroFinalScore[hero.id] > 0;
        };
    }
});
'use strict';

angular.module('overwatch-hero-picker').component('owMapList', {
    bindings: {
        selectedMap: '='
    },
    template:'<ul class=list><li ng-repeat="map in $ctrl.maps | filter: search | orderBy: \'type\'" ng-class="{ \'selected\': $ctrl.selectedMap === map.id, \'disabled\' : $ctrl.selectedMap !== null && map !== $ctrl.selectedMap }"><a ng-click=$ctrl.selectMap(map) href=javscript:void()><img ng-src={{map.image}}><div class=detail-wrapper><span class=name>{{map.name}}</span></div></a></li></ul>',
    controller: function controller(MapsService, $document, $scope) {
        var _this = this;

        this.selectedMap = null;

        MapsService.getMaps().then(function (maps) {
            _this.maps = maps;
        });

        this.selectMap = function (map) {
            if (map === _this.selectedMap) {
                _this.selectedMap = null;
            } else {
                _this.selectedMap = map;
            }
        };
    }
});
'use strict';

angular.module('overwatch-hero-picker').service('HeroesService', function ($http) {
    this.getHeroes = function () {
        return $http.get('data/heroes.json').then(function (response) {
            return response.data;
        });
    };
    this.getMatching = function () {
        return $http.get('data/matching.json').then(function (response) {
            return response.data;
        });
    };
});
'use strict';

angular.module('overwatch-hero-picker').service('HeroPickerService', function ($q, HeroesService) {

    this.getRecommendedHero = function (opposingHeroes, map) {
        return $q.all({
            heroes: HeroesService.getHeroes(),
            matching: HeroesService.getMatching()
        }).then(function (result) {
            var recommendedCounterByHero = {};
            var recommendedByMap = {};
            var finalRating = {};
            var nbOpponent = Object.keys(opposingHeroes).length || 6;

            //(Hero1+Hero2+Hero3+Hero4+Hero5+Hero6+(MapRating x opposingHeroesCount *.4)) x PlayerRating
            for (var pickHeroId in result.matching) {
                if (result.matching.hasOwnProperty(pickHeroId)) {
                    recommendedCounterByHero[pickHeroId] = 0;

                    for (var opposingHeroId in opposingHeroes) {
                        if (opposingHeroes.hasOwnProperty(opposingHeroId)) {
                            recommendedCounterByHero[pickHeroId] += result.matching[pickHeroId].heroes[opposingHeroId] || 0;
                        }
                    }

                    if (map) {
                        recommendedByMap[pickHeroId] = result.matching[pickHeroId].maps[map.id] || 0;
                    } else {
                        recommendedByMap[pickHeroId] = 0;
                    }
                    finalRating[pickHeroId] = recommendedCounterByHero[pickHeroId] * -1 + recommendedByMap[pickHeroId] * nbOpponent * .4;
                }
            }

            return {
                heroCounterRating: recommendedCounterByHero,
                heroMapRating: recommendedByMap,
                finalRating: finalRating
            };
        });
    };
});
'use strict';

angular.module('overwatch-hero-picker').service('MapsService', function ($http) {
    this.getMaps = function () {
        return $http.get('data/maps.json').then(function (response) {
            return response.data;
        });
    };
});