'use strict';

angular.module('overwatch-hero-picker', []);
'use strict';

angular.module('overwatch-hero-picker').config(function ($httpProvider) {
    $httpProvider.defaults.cache = true;
});
'use strict';

angular.module('overwatch-hero-picker').constant('MapModes', {
    O: "Offense",
    D: "Defense",
    KOTH: "King of the Hill"
});
'use strict';

angular.module('overwatch-hero-picker').component('owHeroList', {
    bindings: {
        selectedHeroes: '=',
        heroesRating: '='
    },
    template:'<ul class=list><li ng-repeat="hero in $ctrl.heroes | filter: search | orderBy: \'name\'" ng-class="{ \'selected\': $ctrl.selectedHeroes[hero.id], \'disabled\' : !$ctrl.selectedHeroes[hero.id] && $ctrl.maxReached }"><a ng-click=$ctrl.selectHero(hero) href=javascript:void()><img ng-src={{hero.avatar}}><div class=detail-wrapper><span class=name>{{hero.name}} <span ng-if=$ctrl.heroesRating[hero.id]>( {{$ctrl.heroesRating[hero.id]}} )</span></span></div></a><ow-player-hero-rating ng-if=$ctrl.heroesRating rating=$ctrl.heroesRating[hero.id]></ow-player-hero-rating></li></ul>',

    controller: function controller(HeroesService) {
        var _this = this;

        var checkMaxReached = function checkMaxReached() {
            _this.maxReached = Object.keys(_this.selectedHeroes).length === 6;
        };

        HeroesService.getHeroes().then(function (heroes) {
            _this.heroes = heroes;
        });

        // $scope.$watch('$ctrl.heroes', function(heroes) {
        //
        //     angular.forEach(heroes, (hero) => {
        //
        //         let heroScope = $scope.$new();
        //
        //         heroScope.hero = hero;
        //         $timeout(function(){
        //             $transclude(heroScope, function(clone, innerScope) {
        //                 //clone is a copy of the transcluded DOM element content.
        //                 console.log(clone);
        //
        //                 //append the transcluded element.
        //                 $element.append($compile(clone)(innerScope));
        //             });
        //         },1000)
        //
        //     });
        // });

        this.selectedHeroes = {};

        checkMaxReached();

        this.selectHero = function (hero) {

            if (angular.isDefined(_this.selectedHeroes[hero.id])) {
                delete _this.selectedHeroes[hero.id];
            } else if (!_this.maxReached) {
                _this.selectedHeroes[hero.id] = hero;
            }

            checkMaxReached();
        };
    }
});
'use strict';

angular.module('overwatch-hero-picker').component('owHeroPickerScore', {
    bindings: {
        map: '<',
        counter: '<',
        final: '<'
    },
    controller: function controller() {
        this.abs = Math.abs;
    },
    template:'<div class=score>{{$ctrl.final * -1 | number:1 }} <small>(C)&nbsp;{{ $ctrl.counter| number: 1 }}</small> <small>(M)&nbsp;{{ $ctrl.map| number: 1 }}</small></div>'
});
'use strict';

angular.module('overwatch-hero-picker').component('owHeroPicker', {
    template:'<main class=content><ow-hero-list class=opponents selected-heroes=$ctrl.selectedHeroes></ow-hero-list><ow-map-list selected-map=$ctrl.selectedMap></ow-map-list><div class=recommendation ng-show=$ctrl.heroesList.length><ul class="recommended clearfix"><li ng-repeat="hero in $ctrl.heroesList | filter: $ctrl.recommendedFilter | limitTo:12"><img ng-src="{{ hero.avatar }}"><ow-hero-picker-score final=$ctrl.heroFinalScore[hero.id] counter=$ctrl.heroCounterScore[hero.id] map=$ctrl.heroMapScore[hero.id]></ow-hero-picker-score></li></ul></div><button class=hamburger ng-click="asideOpen = !asideOpen">Player settings</button><aside ng-class="{open : asideOpen}"><ow-hero-list selected-heroes=$ctrl.selectedHeroes></ow-hero-list></aside></main>',
    controller: function controller($q, $scope, HeroesService, HeroPickerService) {
        var _this = this;

        this.selectedHeroes = [];
        this.heroesList = [];
        this.heroesRating = {};
        this.selectedMap = null;

        $scope.$watch('$ctrl.selectedMap', function (value) {
            if (angular.isDefined(value)) {
                _this.getRecommendedHero();
            }
        });

        $scope.$watchCollection('$ctrl.selectedHeroes', function (value) {
            if (value) {
                _this.getRecommendedHero();
            }
        });

        this.getRecommendedHero = function () {
            return $q.all({
                ratings: HeroPickerService.getRecommendedHero(_this.selectedHeroes, _this.selectedMap),
                heroesList: HeroesService.getHeroes()
            }).then(function (r) {
                _this.heroFinalScore = r.ratings.finalRating;
                _this.heroCounterScore = r.ratings.heroCounterRating;
                _this.heroMapScore = r.ratings.heroMapRating;

                _this.heroesList = r.heroesList.sort(function (heroA, heroB) {
                    return r.ratings.finalRating[heroA.id] - r.ratings.finalRating[heroB.id];
                });
            });
        };

        this.recommendedFilter = function (hero) {
            return _this.heroFinalScore[hero.id] <= 0;
        };
        this.avoidFilter = function (hero) {
            return _this.heroFinalScore[hero.id] > 0;
        };
    }
});
'use strict';

angular.module('overwatch-hero-picker').component('owMapList', {
    bindings: {
        selectedMap: '='
    },
    template:'<ul class=list><li ng-repeat="map in $ctrl.maps" class="{{\'mode\' + map.mode}}" ng-class="{ \'selected\': $ctrl.selectedMap === map, \'disabled\' : $ctrl.selectedMap !== null && map !== $ctrl.selectedMap }"><a ng-click=$ctrl.selectMap(map) href=javascript:void();><img ng-src={{map.image}}><div class=detail-wrapper><span class=name>{{map.name}}</span></div></a></li></ul>',
    controller: function controller(MapsService, MapModes) {
        var _this = this;

        this.selectedMap = null;
        this.mapModes = MapModes;
        MapsService.getMaps().then(function (maps) {
            _this.maps = maps.sort(function (a, b) {
                if (a.mode === 'KOTH' && b.mode !== 'KOTH') {
                    return 1;
                }
                if (b.mode === 'KOTH' && a.mode !== 'KOTH') {
                    return -1;
                }
                if (a.id > b.id) {
                    return 1;
                }
                if (a.id < b.id) {
                    return -1;
                }
                //
                // if (a.mode === 'O' && b.mode === 'D'){
                //     return 1;
                // }
                // if (b.mode === 'D' && a.mode === 'O'){
                //     return -1
                // }

                return 0;
            });
        });

        this.selectMap = function (map) {
            if (map === _this.selectedMap) {
                _this.selectedMap = null;
            } else {
                _this.selectedMap = map;
            }
        };
    }
});
'use strict';

angular.module('overwatch-hero-picker').component('owPlayerHeroRating', {

    bindings: {
        rating: '='
    },
    controller: function controller() {},
    template:'<input type=range min=0 max=100 ng-model=$ctrl.rating>'
});
'use strict';

angular.module('overwatch-hero-picker').service('HeroesService', function ($http) {
    this.getHeroes = function () {
        return $http.get('data/heroes.json').then(function (response) {
            return response.data;
        });
    };
    this.getMatching = function () {
        return $http.get('data/matching.json').then(function (response) {
            return response.data;
        });
    };
});
'use strict';

angular.module('overwatch-hero-picker').service('HeroPickerService', function ($q, HeroesService) {

    this.getRecommendedHero = function (opposingHeroes, map) {
        return $q.all({
            heroes: HeroesService.getHeroes(),
            matching: HeroesService.getMatching()
        }).then(function (result) {
            var recommendedCounterByHero = {};
            var recommendedByMap = {};
            var finalRating = {};
            var nbOpponent = Object.keys(opposingHeroes).length || 6;

            //(Hero1+Hero2+Hero3+Hero4+Hero5+Hero6+(MapRating x opposingHeroesCount *.4)) x PlayerRating
            for (var pickHeroId in result.matching) {
                if (result.matching.hasOwnProperty(pickHeroId)) {
                    recommendedCounterByHero[pickHeroId] = 0;

                    for (var opposingHeroId in opposingHeroes) {
                        if (opposingHeroes.hasOwnProperty(opposingHeroId)) {
                            recommendedCounterByHero[pickHeroId] += result.matching[pickHeroId].heroes[opposingHeroId] || 0;
                        }
                    }

                    if (map) {
                        recommendedByMap[pickHeroId] = result.matching[pickHeroId].maps[map.id] || 0;
                    } else {
                        recommendedByMap[pickHeroId] = 0;
                    }
                    finalRating[pickHeroId] = recommendedCounterByHero[pickHeroId] * -1 + recommendedByMap[pickHeroId] * nbOpponent * .4;
                }
            }

            return {
                heroCounterRating: recommendedCounterByHero,
                heroMapRating: recommendedByMap,
                finalRating: finalRating
            };
        });
    };
});
'use strict';

angular.module('overwatch-hero-picker').service('MapsService', function ($http) {
    this.getMaps = function () {
        return $http.get('data/maps.json').then(function (response) {
            return response.data;
        });
    };
});